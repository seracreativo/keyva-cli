//
//  EnvExporter.swift
//  KeyvaCore
//

import Foundation

public enum ExportFormat: String, CaseIterable, Identifiable, Sendable {
    case dotenv = ".env"
    case json = "JSON"
    case yaml = "YAML"
    case xcconfig = "xcconfig"

    public var id: String { rawValue }

    public var fileExtension: String {
        switch self {
        case .dotenv: return "env"
        case .json: return "json"
        case .yaml: return "yaml"
        case .xcconfig: return "xcconfig"
        }
    }

    public var mimeType: String {
        switch self {
        case .dotenv: return "text/plain"
        case .json: return "application/json"
        case .yaml: return "text/yaml"
        case .xcconfig: return "text/plain"
        }
    }

    public var icon: String {
        switch self {
        case .dotenv: return "doc.text"
        case .json: return "curlybraces"
        case .yaml: return "list.bullet.indent"
        case .xcconfig: return "hammer"
        }
    }
}

public struct EnvExporter {

    /// Export variables to the specified format
    public static func export(
        variables: [Variable],
        format: ExportFormat,
        includeSecrets: Bool,
        keychain: KeychainService
    ) async -> String {
        switch format {
        case .dotenv:
            return await exportDotEnv(variables, includeSecrets: includeSecrets, keychain: keychain)
        case .json:
            return await exportJSON(variables, includeSecrets: includeSecrets, keychain: keychain)
        case .yaml:
            return await exportYAML(variables, includeSecrets: includeSecrets, keychain: keychain)
        case .xcconfig:
            return await exportXcconfig(variables, includeSecrets: includeSecrets, keychain: keychain)
        }
    }

    // MARK: - .env Export

    private static func exportDotEnv(
        _ variables: [Variable],
        includeSecrets: Bool,
        keychain: KeychainService
    ) async -> String {
        var lines: [String] = []
        lines.append("# Generated by Keyva")
        lines.append("# \(Date().formatted(date: .abbreviated, time: .shortened))")
        lines.append("")

        let sortedVariables = variables.sorted { $0.order < $1.order }

        for variable in sortedVariables {
            let value = await getValue(for: variable, includeSecrets: includeSecrets, keychain: keychain)
            let escapedValue = formatDotEnvValue(value)

            if variable.isSecret && !includeSecrets {
                lines.append("# \(variable.key)=[REDACTED]")
            } else {
                lines.append("\(variable.key)=\(escapedValue)")
            }
        }

        return lines.joined(separator: "\n")
    }

    private static func formatDotEnvValue(_ value: String) -> String {
        let needsQuotes = value.contains(" ") ||
                         value.contains("\"") ||
                         value.contains("'") ||
                         value.contains("#") ||
                         value.contains("$") ||
                         value.isEmpty

        if needsQuotes {
            let escaped = value.replacingOccurrences(of: "\\", with: "\\\\")
                              .replacingOccurrences(of: "\"", with: "\\\"")
            return "\"\(escaped)\""
        }

        return value
    }

    // MARK: - JSON Export

    private static func exportJSON(
        _ variables: [Variable],
        includeSecrets: Bool,
        keychain: KeychainService
    ) async -> String {
        var dict: [String: String] = [:]
        let sortedVariables = variables.sorted { $0.key < $1.key }

        for variable in sortedVariables {
            let value = await getValue(for: variable, includeSecrets: includeSecrets, keychain: keychain)

            if variable.isSecret && !includeSecrets {
                dict[variable.key] = "[REDACTED]"
            } else {
                dict[variable.key] = value
            }
        }

        guard let data = try? JSONSerialization.data(
            withJSONObject: dict,
            options: [.prettyPrinted, .sortedKeys]
        ), let string = String(data: data, encoding: .utf8) else {
            return "{}"
        }

        return string
    }

    // MARK: - YAML Export

    private static func exportYAML(
        _ variables: [Variable],
        includeSecrets: Bool,
        keychain: KeychainService
    ) async -> String {
        var lines: [String] = []
        lines.append("# Generated by Keyva")
        lines.append("# \(Date().formatted(date: .abbreviated, time: .shortened))")
        lines.append("")

        let sortedVariables = variables.sorted { $0.order < $1.order }

        for variable in sortedVariables {
            let value = await getValue(for: variable, includeSecrets: includeSecrets, keychain: keychain)

            if variable.isSecret && !includeSecrets {
                lines.append("# \(variable.key): [REDACTED]")
            } else {
                let formattedValue = formatYAMLValue(value)
                lines.append("\(variable.key): \(formattedValue)")
            }
        }

        return lines.joined(separator: "\n")
    }

    private static func formatYAMLValue(_ value: String) -> String {
        let needsQuotes = value.contains(":") ||
                         value.contains("#") ||
                         value.hasPrefix(" ") ||
                         value.hasSuffix(" ") ||
                         value.contains("\n") ||
                         value.isEmpty

        if needsQuotes {
            let escaped = value.replacingOccurrences(of: "\\", with: "\\\\")
                              .replacingOccurrences(of: "\"", with: "\\\"")
                              .replacingOccurrences(of: "\n", with: "\\n")
            return "\"\(escaped)\""
        }

        return value
    }

    // MARK: - xcconfig Export

    private static func exportXcconfig(
        _ variables: [Variable],
        includeSecrets: Bool,
        keychain: KeychainService
    ) async -> String {
        var lines: [String] = []
        lines.append("// Generated by Keyva")
        lines.append("// \(Date().formatted(date: .abbreviated, time: .shortened))")
        lines.append("//")
        lines.append("// Usage: Add to your Xcode project and set in Build Settings")
        lines.append("// Reference in Info.plist as $(VARIABLE_NAME)")
        lines.append("")

        let sortedVariables = variables.sorted { $0.order < $1.order }

        for variable in sortedVariables {
            let value = await getValue(for: variable, includeSecrets: includeSecrets, keychain: keychain)

            if variable.isSecret && !includeSecrets {
                lines.append("// \(variable.key) = [REDACTED]")
            } else {
                let escapedValue = value.replacingOccurrences(of: "$(", with: "$$(")
                lines.append("\(variable.key) = \(escapedValue)")
            }
        }

        if variables.contains(where: { $0.isSecret }) {
            lines.append("")
            lines.append("// WARNING: Secret values in xcconfig files are compiled into your app bundle")
            lines.append("// Consider using a .env file for runtime secrets instead")
        }

        return lines.joined(separator: "\n")
    }

    // MARK: - Helpers

    private static func getValue(
        for variable: Variable,
        includeSecrets: Bool,
        keychain: KeychainService
    ) async -> String {
        if variable.isSecret {
            if includeSecrets {
                do {
                    return try await keychain.retrieve(for: variable.id)
                } catch KeychainError.itemNotFound {
                    return "[NO_VALUE_STORED]"
                } catch {
                    return "[KEYCHAIN_ERROR]"
                }
            } else {
                return "[REDACTED]"
            }
        }
        return variable.value
    }
}
